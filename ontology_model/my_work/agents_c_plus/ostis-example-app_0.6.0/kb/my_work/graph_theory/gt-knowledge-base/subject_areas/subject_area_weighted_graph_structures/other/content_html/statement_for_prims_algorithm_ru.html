На вход алгоритма подаётся <sc_element sys_idtf  = "concept_connected_graph">связный</sc_element> <sc_element sys_idtf  = "concept_connected_graph">связного</sc_element><sc_element sys_idtf  = "concept_undirected_graph">неориентированный граф</sc_element>. Для каждого ребра задаётся его <sc_element sys_idtf  = "nrel_weight">вес</sc_element>.
Сначала берётся произвольная <sc_element sys_idtf  = "concept_node">вершина</sc_element>  и находится <sc_element sys_idtf  = "concept_arg">ребро</sc_element> , инцидентное данной вершине и обладающее наименьшим <sc_element sys_idtf  = "nrel_weight">весом</sc_element>. Найденное <sc_element sys_idtf  = "concept_arg">ребро</sc_element> и соединяемые им две вершины образуют <sc_element sys_idtf  = "concept_tree">дерево</sc_element> . Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Таким образом, при выполнении каждого шага алгоритма, высота формируемого дерева увеличивается на 1. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.